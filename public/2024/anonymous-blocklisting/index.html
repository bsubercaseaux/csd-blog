<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

    
      
    

      <title>CMU CSD PhD Blog - Efficient Anonymous Blocklisting</title>

      
          
          <link rel="alternate" type="application/rss+xml" title="RSS" href="https://www.cs.cmu.edu/~csd-phd-blog/rss.xml">
          
      

      
          <script src="https://cdnjs.cloudflare.com/ajax/libs/slideout/1.0.1/slideout.min.js"></script>

          <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">

          <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd" crossorigin="anonymous"></script>

          <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"
              onload="renderMathInElement(document.body);"></script>


          
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">

          <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd" crossorigin="anonymous"></script>
          <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/mathtex-script-type.min.js" integrity="sha384-OGHJvxKrLNowXjZcg7A8ziPZctl4h7FncefPoKSuxgVXFxeM87GCKFJvOaTeBB9q" crossorigin="anonymous"></script>
          
              <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"
              onload="renderMathInElement(document.body);"></script>
              
          
      

      
          <link rel="stylesheet" href="https://www.cs.cmu.edu/~csd-phd-blog/site.css">
          
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
          
      

      
      
    </head>

    <body>
        <div class="container">

            <div id="mobile-navbar" class="mobile-navbar">
              <div class="mobile-header-logo">
                <a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~csd-phd-blog" class="logo">CSD PhD Blog</a>
              </div>
              <div class="mobile-navbar-icon icon-out">
                <span></span>
                <span></span>
                <span></span>
              </div>
            </div>

            <nav id="mobile-menu" class="mobile-menu slideout-menu slideout-menu-left">
              <ul class="mobile-menu-list">
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~csd-phd-blog&#x2F;">
                            Home
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~csd-phd-blog&#x2F;areas">
                            Areas
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~csd-phd-blog&#x2F;tags">
                            Tags
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~csd-phd-blog&#x2F;rss.xml">
                            RSS
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;csd.cmu.edu">
                            CSD
                        </a>
                    </li>
                
              </ul>
            </nav>

            <header id="header">
                <div class="logo">
                    <img src="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~csd-phd-blog/csd.svg" alt="CSD Logo">
                    <div class="logo-text">
                        <a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~csd-phd-blog">CSD PhD Blog</a>
                    </div>
                </div>
                <nav class="menu">
                    <ul>
                        
                            <li>
                                
                                    <a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~csd-phd-blog&#x2F;">
                                        Home
                                    </a>
                                
                            </li>
                        
                            <li>
                                
                                    <a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~csd-phd-blog&#x2F;areas">
                                        Areas
                                    </a>
                                
                            </li>
                        
                            <li>
                                
                                    <a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~csd-phd-blog&#x2F;tags">
                                        Tags
                                    </a>
                                
                            </li>
                        
                            <li>
                                
                                    <a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~csd-phd-blog&#x2F;rss.xml">
                                        RSS
                                    </a>
                                
                            </li>
                        
                            <li>
                                
                                    <a href="https:&#x2F;&#x2F;csd.cmu.edu" target="_blank">CSD</a>
                                
                            </li>
                        
                    </ul>
                </nav>
            </header>

            <main>
                <div class="content" id="mobile-panel">
                    


<div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content always-active">
        <nav id="TableOfContents">
            <ul>
                
                <li>
                    <a href="https://www.cs.cmu.edu/~csd-phd-blog/2024/anonymous-blocklisting/#tl-dr" class="toc-link">TL;DR:</a>
                    
                </li>
                
                <li>
                    <a href="https://www.cs.cmu.edu/~csd-phd-blog/2024/anonymous-blocklisting/#introduction" class="toc-link">Introduction¬†</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://www.cs.cmu.edu/~csd-phd-blog/2024/anonymous-blocklisting/#anonymous-communications-systems" class="toc-link">Anonymous Communications Systems</a>
                        </li>
                        
                        <li>
                            <a href="https://www.cs.cmu.edu/~csd-phd-blog/2024/anonymous-blocklisting/#anonymous-blocklisting" class="toc-link">Anonymous Blocklisting</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="https://www.cs.cmu.edu/~csd-phd-blog/2024/anonymous-blocklisting/#cryptographic-protocols" class="toc-link">Cryptographic Protocols</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://www.cs.cmu.edu/~csd-phd-blog/2024/anonymous-blocklisting/#zk-snarks" class="toc-link">ZK-SNARKs</a>
                        </li>
                        
                        <li>
                            <a href="https://www.cs.cmu.edu/~csd-phd-blog/2024/anonymous-blocklisting/#signature-schemes" class="toc-link">Signature Schemes</a>
                        </li>
                        
                        <li>
                            <a href="https://www.cs.cmu.edu/~csd-phd-blog/2024/anonymous-blocklisting/#commitment-schemes" class="toc-link">Commitment Schemes</a>
                        </li>
                        
                        <li>
                            <a href="https://www.cs.cmu.edu/~csd-phd-blog/2024/anonymous-blocklisting/#pseudorandom-functions-prfs" class="toc-link">Pseudorandom Functions (PRFs)</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="https://www.cs.cmu.edu/~csd-phd-blog/2024/anonymous-blocklisting/#anonymous-blocklisting-1" class="toc-link">Anonymous Blocklisting</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://www.cs.cmu.edu/~csd-phd-blog/2024/anonymous-blocklisting/#definition" class="toc-link">Definition</a>
                        </li>
                        
                        <li>
                            <a href="https://www.cs.cmu.edu/~csd-phd-blog/2024/anonymous-blocklisting/#inefficient-constructions" class="toc-link">Inefficient Constructions</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="https://www.cs.cmu.edu/~csd-phd-blog/2024/anonymous-blocklisting/#snarkblock" class="toc-link">SNARKBlock</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://www.cs.cmu.edu/~csd-phd-blog/2024/anonymous-blocklisting/#hiciap" class="toc-link">HICIAP</a>
                        </li>
                        
                        <li>
                            <a href="https://www.cs.cmu.edu/~csd-phd-blog/2024/anonymous-blocklisting/#efficiency" class="toc-link">Efficiency</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="https://www.cs.cmu.edu/~csd-phd-blog/2024/anonymous-blocklisting/#conclusion" class="toc-link">Conclusion</a>
                    
                </li>
                
            </ul>
        </nav>
    </div>
</div>


<article class="post">
    
    <header class="post__header">
        <h1 class="post__title">
            <a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~csd-phd-blog&#x2F;2024&#x2F;anonymous-blocklisting&#x2F;">Efficient Anonymous Blocklisting</a>
        </h1>
        <div class="post__meta">
            <span class="post__time">2024-07-31</span> |
            <span class="post__author">
              



  
  


<a href="https:&#x2F;&#x2F;orestischar.com&#x2F;" target=_blank>
  Orestis Chardouvelis
</a>

            </span>
            
        </div>
    </header>
    
      
    
      
    
      
    
    

    <div class="post-content">
      <h2 id="tl-dr">TL;DR:</h2>
<ul>
<li>Truly Anonymous Service Providers can offer users confirmed privacy, but also allow inappropriate behavior üò≥</li>
<li>Anonymous Blocklisting permits blocking ill-behaved users without denanonymizing them. Specifically, the service provider blocks individual posts, and the benign users use zero-knowledge arguments (zk-SNARKs) to prove that they didn‚Äôt make said posts, without revealing any information about them üòÆ</li>
<li>The more blocked posts you have the less efficient the blocklist is, making it practically infeasible üòû</li>
<li>SNARKBlock reduces the cost to logarithmic with respect to the size of the blocklist by introducing HICIAP, aggregating all the individual proofs into one efficient proof üôå</li>
<li>You can now live out your anonymous double life üòé</li>
</ul>
<h1 id="introduction">Introduction¬†</h1>
<p>The goal of this blog post is to teach the reader the fundamentals behind anonymous blocklisting, as well as to introduce a state-of-the-art blocklisting algorithm called SNARKBlock. In the conclusion, I will reflect on open problems for future anonymous blocklisting algorithms.</p>
<h2 id="anonymous-communications-systems">Anonymous Communications Systems</h2>
<p>Anonymous communications systems bring benefits but also harms. Computing users‚Äô private information has always been vulnerable to irresponsible corporations and identity theft. On top of that, oppressed citizens living under authoritarian governments struggle to maintain their privacy and risk facing prosecution for speaking out, while political journalists have to fight to keep their sources hidden. Anonymous communications systems aim to help these users by keeping their identities private from other observers.
The largest network that allows anonymous communication to date is <a rel="noopener" target="_blank" href="https://svn-archive.torproject.org/svn/projects/design-paper/tor-design.pdf">Tor</a>, which utilizes ‚Äúonion routing‚Äù, encrypting the data multiple times and passing it through a network of different nodes, making it difficult to trace back to the source. Unfortunately, malicious users can take advantage of the gift of anonymity resulting in online bullying and harassment, trolling, and the spread of harmful or illegal content without consequences. The problem is the following:</p>
<p><em>If no one knows who you are, no one can stop you.</em></p>
<!-- <p></p> -->
<p>How can internet services provide anonymity to users without allowing inappropriate behavior?
Many service providers claim to be anonymous but have often been criticized for storing the user‚Äôs information, or metadata that can help identify them.<!--, like [Whisper](https://whisper.sh/) and [Blind](https://www.teamblind.com/). Another example is--> For instance, <a rel="noopener" target="_blank" href="https://www.wikipedia.org/">Wikipedia</a> provides weak anonymity by connecting a user‚Äôs personal information to a pseudonym instead of directly storing it. Thus, all of their actions (e.g., page edits) are publicly linked to their profile, and analyzing patterns in editing behavior or content preferences could lead to inferences about their identity.
One existing solution to linked metadata is using ‚Äúrevocable anonymity systems‚Äù, which allow for a user to be deanonymized or pseudoanonymized (having their actions linked) when necessary. For example, imagine if Wikipedia users were completely anonymous (i.e., without a public pseudonym), but if one of your edits is deemed ‚Äúinappropriate‚Äù, your anonymity is stripped and your identity is revealed. This type of system typically relies on a Trusted Third Party aware of the identity of the user and capable of revoking a user‚Äôs privacy at their discretion.</p>
<h2 id="anonymous-blocklisting">Anonymous Blocklisting</h2>
<p>Anonymous blocklisting systems come to the rescue to enforce policies on users without deanonymizing them. These systems allow users to authenticate anonymously with a service provider, while service providers can revoke a user‚Äôs access without learning any information about their identity or involving a Trusted Third Party. Anonymous blocklisting systems can achieve blocking users from posting again by flagging individual posts instead of their accounts.</p>
<p>A way to realize this is to provide each user with a secret identity, and every one of their posts is secretly linked to that identity. Unlike the example with the Wikipedia users, there is not a public pseudonym connected to them, and their identity remains hidden even from the service provider. Whenever a user wants to post they have to prove that none of the flagged posts are linked to their identity, without leaking any information about it.</p>
<p>A savvy reader (you) can spot an immediate problem; how can we prevent users from making many different accounts? This is a common network service attack called the <a rel="noopener" target="_blank" href="https://www.freehaven.net/anonbib/cache/sybil.pdf">Sybil Attack</a>.¬† In a ‚Äúnormal‚Äù system, users have to register through an identity provider (e.g., Google) using some identifier (e.g., their Gmail account). To solve this problem, blocklisting schemes can also utilize identity providers who would maintain a log of ‚Äúregistered users‚Äù. Hence, when a user posts, they have to also prove they are registered without revealing it‚Äôs them posting, using <del>magic</del> cryptography.</p>
<p>To summarize, anonymous blocklisting systems achieve blocking anonymous users without the need to deanonymize them. They allow users to post anonymously (even to the service provider), while service providers can block individual posts without any of the user‚Äôs information getting leaked.</p>
<h1 id="cryptographic-protocols">Cryptographic Protocols</h1>
<p>To delve deeper into the mechanics of anonymous blocklisting schemes, we‚Äôll go over some cryptographic protocols that help ensure the users‚Äô privacy.</p>
<h2 id="zk-snarks">ZK-SNARKs</h2>
<p>The main building block needed to build an anonymous blocklisting scheme is called a <a rel="noopener" target="_blank" href="https://www.di.ens.fr/~nitulesc/files/Survey-SNARKs.pdf">zk-SNARK</a>; Zero-Knowledge Succinct Non-Interactive Argument of Knowledge. Even if it is a mouthful, every single property is necessary. Let‚Äôs break them down together below. Assume we have two parties denoted as the Prover and the Verifier.</p>
<ul>
<li>Argument of Knowledge: A SNARK is a proof<sup class="footnote-reference"><a href="#1">1</a></sup> where the Prover can prove their possession of some information to the Verifier. Typically, the ‚Äúinformation‚Äù is the solution (‚Äúwitness‚Äù) to a computational problem that the Verifier could not solve by themselves.<!-- without knowledge of the information they are proving possession of.--></li>
<li>Non-Interactive: The communication between the two parties solely consists of a single proof message sent from the Prover to the Verifier (in more general models, the Verifier and Prover could engage in multiple rounds of interactive communication).</li>
<li>Succinct: The Prover‚Äôs message should be small compared to their witness.</li>
<li><a rel="noopener" target="_blank" href="https://people.csail.mit.edu/silvio/Selected%20Scientific%20Papers/Proof%20Systems/The_Knowledge_Complexity_Of_Interactive_Proof_Systems.pdf">Zero-Knowledge</a>: The Prover manages to prove possession of their witness without revealing any information about the witness itself.</li>
</ul>
<p>The crux of the whole protocol is the zero-knowledge property which can accompany a SNARK. To make Zero - Knowledge more tangible we can revisit one of the most overdone examples in the history of ZK, drawing from the world of <a rel="noopener" target="_blank" href="https://www.imdb.com/title/tt0417299/">Avatar: The Last Airbender</a><sup class="footnote-reference"><a href="#2">2</a></sup>. Imagine our Prover is Aang, and our Verifier is Toph. Aang has two different colored boomerangs (one red and one green) and wants to prove to Toph who is (color)blind that they are indeed different colors. However, Aang doesn‚Äôt want to let Toph know which boomerang is which color! Thankfully, they came up with the following Zero-Knowledge Protocol: Toph holds the boomerangs behind her back. She briefly displays one of the two boomerangs before hiding it again. She then again chooses one of the two at random, brings it out, and asks ‚ÄúDid I switch the boomerangs?‚Äù. Of course, Toph knows if she displayed the same or a different boomerang, and Aang can easily differentiate given their different colors. If Aang lies, he will only succeed 50% of the time. By repeating the protocol multiple times, Toph can be convinced, without actually learning any information about the individual boomerang‚Äôs colors!</p>
<!--<img src="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExdW4wYmRsaDZkcnkzbHNpbzc1OW40djVmbDkxN3B5d2t0azd5cXllciZlcD12MV9naWZzX3NlYXJjaCZjdD1n/4IzOgM1bfOe6k/giphy.gif" width="45%"/>-->
<img src="toph.gif" width="40%"/>
<p>Of course in this example, even though we demonstrate the ZK property, this is not a SNARK since it is interactive. With a ZK-SNARK, Toph and Aang would not need multiple rounds of communication.</p>
<h2 id="signature-schemes">Signature Schemes</h2>
<p>Another cryptographic protocol required to understand anonymous blocklisting is a <a rel="noopener" target="_blank" href="https://people.csail.mit.edu/rivest/pubs/GMR88.pdf">signature scheme</a>. A digital signature, just like a real-life signature, gives a Prover the ability to sign a message before sending it. Then a Verifier, using some public information, can verify that the Prover was the one who sent that message. Signature Schemes consist of 3 algorithms:</p>
<ul>
<li>Generation Algorithm<!-- \\( Gen(\lambda) \leftarrow (sk,vk) \\)-->: It produces a signature (secret) key <em>sk</em> only known by the signer and a verification key <em>vk</em> public to everyone.</li>
<li>Signing Algorithm<!-- \\(Sig(sk, m) \leftarrow \sigma\\)-->: Given a message <em>m</em> and the secret key <em>sk</em>, it produces the digital signature œÉ.</li>
<li>Verification Algorithm<!-- \\(Ver(vk, m, \sigma) \leftarrow \{0,1\}\\)-->: Given the public verification key <em>vk</em>, the original message <em>m</em> and the signature œÉ, it produces 1 if the signature is valid and 0 if it‚Äôs not.</li>
</ul>
<p>Signature schemes allow users to authenticate the origin and integrity of a message. Let‚Äôs understand their importance through another Avatar example, where Zuko is trying to capture the Avatar<sup class="footnote-reference"><a href="#2">2</a></sup>. Imagine Zuko wants to announce to the world online, and as an extension his dad -the Firelord-, that he caught the Avatar. However, anyone can try and give false information, impersonating Zuko, and claim the Avatar has been caught. To avoid this scenario, Zuko sets up a digital signature scheme; he runs the Generation algorithm and shares the (public) verification key with his dad before his trip. Now, if he catches the Avatar, he can publish his message ‚ÄúI caught the Avatar, and with him, my honor‚Äù, along with a signature œÉ. As a result, the Firelord can run the (public) verification algorithm, which would return true if this message is truly from Zuko, or false, indicating it did not, in fact, come from Zuko.</p>
<img src="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb28zZW5yaHozNjd0NmM5MGdudnZ6dWMwYmxuYjQxamVwdjZhMWlrZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/kN2THUm8712diLwn0F/giphy.gif" width="50%"/>
<h2 id="commitment-schemes">Commitment Schemes</h2>
<p>We will also encounter a <a rel="noopener" target="_blank" href="https://www.cs.cmu.edu/~mblum/research/pdf/coin/">commitment scheme</a>, which allows one to commit to a specific value while keeping it hidden from everyone else. In addition, the committed value can be revealed later without any possibility of alteration. This ensures both confidentiality and integrity, ensuring that the committed value is securely locked and that after revealing it, the original commitment and the revealed value match perfectly. Commitment schemes consist of the following two phases, which take place between a committer and a receiver:</p>
<ul>
<li>The commit phase, during which the committer chooses and commits to a value by producing a ‚Äúcommitment‚Äù message.</li>
<li>The reveal phase, during which the committer sends the value to the receiver along with a ‚Äúdecommitment‚Äù message (e.g. the randomness used in the commit phase), and the receiver can verify its authenticity.</li>
</ul>
<p>Commitment schemes have to satisfy two properties:</p>
<ul>
<li>Hiding property: Given a commitment, no information about the committed value can be extracted.</li>
<li>Binding Property: The value chosen in the commit phase is the only one that the commitment can decommit to.</li>
</ul>
<p>Assume that Aang and Toph are playing a game where Toph thinks of a number between 1 and 10, and Aang tries to guess it. They want to ensure that Toph cannot change her pick after Aang makes his guess, so they use a commitment scheme. Toph thinks of the number 7 and sends a commitment to Aang. Then Aang makes his guess and says: ‚ÄúI think the number is 5‚Äù. Finally, Toph reveals her pick by sending a decommitment message. Due to the properties of the commitment scheme, Aang cannot cheat and get any information about Toph‚Äôs number before the reveal phase. At the same time, if Aang guessed 7 correctly, Toph cannot lie about her initial pick claiming it was a different number.</p>
<!--Assume that Aang wants to correctly guess how many guards Suki can take down, without letting her know beforehand. However, Suki doesn't trust him, so they use a commitment scheme. Soka guesses 42 and produces and sends a commitment message to Suki. After the fight, Aang reveals his answer, while also sending a decommitment message. Now, if the real number of guards was 43, Soka could not change his answer and still convince Suki he was right. At the same time, Suki cannot get any information about Aang's answer before the reveal phase and change her actions during the fight.

![suki](https://64.media.tumblr.com/5fe3d1ed55146768d4aabbb7a419f132/9b647a9d5c31eada-f0/s250x400/4814c265ff350458f9beb79eb4b7fe62509590ef.gifv)-->
<h2 id="pseudorandom-functions-prfs">Pseudorandom Functions (PRFs)</h2>
<p>The last protocol we will refer to is a <a rel="noopener" target="_blank" href="https://www.wisdom.weizmann.ac.il/~oded/X/ggm.pdf">pseudorandom function</a>, or PRF. A PRF is a function that takes as input a key and a message, and returns a random-looking string: <em>PRK(key, message) = pseudorandom string</em>. A PRF must have the following two properties:</p>
<ul>
<li>It is easy to compute (i.e., in polynomial time).</li>
<li>One cannot distinguish between random strings and the results of a PRF without access to the key.</li>
</ul>
<p>In other words, randomness is expensive; PRFs are cryptography‚Äôs efficient way of faking randomness.</p>
<h1 id="anonymous-blocklisting-1">Anonymous Blocklisting</h1>
<p>We will now focus on anonymous blocklisting schemes, starting with their necessary properties and continue by doing a survey of state-of-the-art systems <a rel="noopener" target="_blank" href="https://eprint.iacr.org/2021/1577.pdf">SNARKBlock</a> and its predecessor <a rel="noopener" target="_blank" href="https://dl.acm.org/doi/pdf/10.1145/1880022.1880033">BLAC</a>.</p>
<p>Overall, in an Anonymous Blocklisting Scheme, there is a blocklist filled with flagged posts. Every user gets a ‚Äúsecret identity‚Äù when they register for the service. Every time they want to post, they have to produce a token that is linked to their identity, and then prove both that they are registered and that none of the flagged posts were made by them. To do that, as we will see later, they can use zero-knowledge proofs, attesting to the fact that their identity is valid (produced during the registration) and that it is not connected to any of the posts in the blocklist, without revealing any actual information about their identity.</p>
<h2 id="definition">Definition</h2>
<p>We will begin with a simplified definition of anonymous blocklisting schemes due to <a rel="noopener" target="_blank" href="https://cacr.uwaterloo.ca/techreports/2010/cacr2010-24.pdf">Henry and Goldberg</a> that can be generalized to most existing blocklisting schemes.</p>
<!--Time to get a bit more technical and see what the requirements and properties of an anonymous blocklisting scheme are. In the literature, there exist numerous definitions that are often too specific to the scheme in question, or too informal. For the purposes of this blog, we are going to draw from [Henry and Goldberg](https://cacr.uwaterloo.ca/techreports/2010/cacr2010-24.pdf) and present a simplified version that can be generalized to most existing blocklisting schemes. Let's start with the parties involved:-->
<p>The parties involved are the following:</p>
<ul>
<li>Users: The set of individuals using the service are called users. All users are assigned to a random unique identifier <em>k</em>, which constitutes their identity and remains secret.</li>
<li>Identity Providers: Every user has to connect to an identity provider (e.g., Google) to register for the service and acquire a new and valid identity.</li>
<li>Service Providers: The entity (or entities) providing the service (e.g., Wikipedia).</li>
<li>Revocation Authorities: The authority responsible for flagging content and blocking users. For the context of this blog, we assume the service providers also play the role of the revocation authorities, which is the case for most blocklisting schemes.</li>
</ul>
<p>The protocols that can take place in an anonymous blocklisting scheme are:</p>
<ul>
<li>Registration Protocol: This protocol takes place between a user and an identity provider and happens once so that the user registers for the service. By running this algorithm, the user receives a valid unique identifier.</li>
<li><!--* Token Extraction Protocol: To anonymously connect a user every time they use a specific service use (e.g. post), the user has to run this protocol with their unique identifier to get an authentication token. As a result, every token is connected to their identity-->Token Extraction Protocol: For a user to take action on the service (e.g., post), they need an authentication token. By running this protocol with their unique identifier, they can obtain a token secretly linked to their identity. This process ensures that the token can be used for authentication while preventing anyone from gaining information about the user's identity by merely observing the token.
</li>
<li>Authorization Protocol: In this protocol, the service provider takes as input an authentication token and verifies that the user is eligible to use the service (i.e., not blocked).</li>
<li>Revocation Protocol: This protocol is run by the service provider, taking as input an authorization token and blocking the user by adding the token to the blocklist.</li>
<li>Reinstatement Protocol: Similarly to the revocation protocol, the service provider can also unban a user by removing their token from the blocklist.</li>
</ul>
<p>The crux of the anonymous blocklisting scheme is ensuring the following three security requirements:</p>
<ul>
<li>
<p>Blocklistability: Users can successfully authenticate to an honest service provider only if that user holds a valid identity not in the blocklist issued by an identity provider: Specifically, it encompasses the following two notions:</p>
<ol>
<li>Verification should succeed only on authentication tokens that are the result of a user correctly executing the established protocols.</li>
<li>Given an authentication token issued to some anonymous user, a service provider can have the user‚Äôs access revoked, such that they cannot post again until all his banned tokens are removed.</li>
</ol>
</li>
<li>
<p>Anonymity: No information about the user can be linked to an authentication token, which encompasses the following two notions:</p>
<ol>
<li>Given an authentication token from one of two users, it should be infeasible for an attacker to determine which user that authentication token was issued to.</li>
<li>Given two or more authentication tokens, it should be infeasible for an attacker to distinguish if they came from the same user or two different ones.</li>
</ol>
</li>
<li>
<p>Non-frameability: An honest user cannot be prevented from being authenticated by an honest service provider.</p>
</li>
</ul>
<p>Let‚Äôs go back to our example setting<sup class="footnote-reference"><a href="#2">2</a></sup> to better better the mechanics of such a scheme. Imagine that the officials of the city of Ba Sing Se have set up an anonymous forum of people sharing secrets from their everyday lives, like the app Whisper, and Joo Dee is an identity provider. Assume that Aang wants to subscribe to the forum and make posts. He first has to get in contact with Joo Dee to register. As an outcome, he gains a unique identifier <em>k</em>, secret even to Joo Dee. Then, assume he wants to post the message ‚ÄúThere is war in Ba Sing Se‚Äù. He runs the token extraction protocol using his identifier to get a token Œ± and anonymously sends the message along with the token to the city officials. Now they run the Authentication Protocol, verify that the message is not coming from a banned user, and publish it.
Of course, it‚Äôs not long before the message gets flagged for harmful content. So the authorities run the revocation algorithm using that token. Now, if Aang tries to post again with a new token, it won‚Äôt be authorized. However, no one can link his message to him or any of his futile attempts to post again.</p>
<img src="https://media.tenor.com/SOnmo9jnfQsAAAAM/avatar-the-last-airbender.gif" width="45%"/>
<h2 id="inefficient-constructions">Inefficient Constructions</h2>
<p>As usual in cryptography, things in practice are a little different, and by different, I mean worse. The security requirements explained above are necessary but not sufficient for a useful in-practice anonymous blocklisting scheme. The size of the blocklist can grow extremely fast depending on the use case.
For example, Wikipedia has approximately <a rel="noopener" target="_blank" href="https://stats.wikimedia.org/#/en.wikipedia.org/contributing/edits/normal%7Cbar%7C2020-11-04~2021-11-24%7C~total%7Cmonthly">2 edits per second</a> and Reddit around <a rel="noopener" target="_blank" href="https://old.reddit.com/r/blog/comments/k967mm/reddit_in_2020/">64 comments per second</a>. Estimating from event logs from 2020, the ban rate for Wikipedia is around 1%, which would result in approximately 2 thousand bans in Wikipedia and 40 thousand bans for Reddit.</p>
<p>We thus need schemes that are efficient, both for the users and the service provider.</p>
<p>On the user‚Äôs side, to be efficient means that authenticating a token and using the service has a predictable runtime and bandwidth so as not to add too much latency to their requests. On the service provider‚Äôs side, we need both the authentication and revocation processes to have predictable running times and bandwidth, so that the cost of servicing a user is not too high and the system can keep up with the expected rate of revocations.</p>
<p>Let‚Äôs start with a construction inspired by the first anonymous blocklisting scheme with a Trusted Third Party, <a rel="noopener" target="_blank" href="https://dl.acm.org/doi/pdf/10.1145/1880022.1880033">BLAC</a> by Tsang et al., to delve deeper into the mechanics<sup class="footnote-reference"><a href="#3">3</a></sup>.
Consider the blocklist as a set of tokens, where every token is of the form <em>(nonce, PRF(k, nonce))</em> for some random number <em>nonce</em> and someone‚Äôs unique identifier <em>k</em>.</p>
<p>The <strong>registration protocol</strong> has to take place once, before the user can access the service. The user randomly chooses his credential <em>k</em>, then computes and sends a commitment <em>com(k)</em> to the identity provider. The identity provider answers with a signature <em>œÉ</em> on that commitment.</p>
<p>During the <strong>token extraction protocol</strong>, the user randomly chooses a value <em>nonce</em> and computes a token <em>Œ± = (nonce, PRF(k, nonce))</em>, tying the token with their identity.</p>
<p>The <strong>authorization protocol</strong> works as follows: the user sends to the service a token <em>Œ±</em>, along with a zk-SNARK that: (i) the token is computed correctly and is equal to <em>PRF(k, nonce)</em>, (ii) they have a well-formed commitment <em>com(k)</em> such that it is signed from an identity provider and (iii) none of the tokens in the blocklist are related to the user‚Äôs identifier, i.e. <!--\\( \forall \alpha=(nonce^\prime, h) \in blocklist,¬† PRF(k, nonce^\prime) \ne h \\)--> <em>for all Œ±=(nonce‚Ä≤, h) in the blocklist,¬† PRF(k, nonce‚Ä≤) ‚â† h</em>.</p>
<p>Then, in the <strong>verification protocol</strong> the service provider checks that the proofs are valid (i.e., the user is not blocked), and only then offers their service.</p>
<p>Finally, for the <strong>revocation protocol</strong>, if the service provider notices harmful content, they add the token accompanying it in the blocklist. Respectively, they can remove it if they decide to unban them by running the <strong>reinstatement protocol</strong>.</p>
<p>It is clear to see the security of this protocol:</p>
<ul>
<li>
<p>The scheme satisfies <strong>blocklistablity</strong> since, if a user is blocked or tries to use fake credentials, their zk-SNARK wouldn‚Äôt verify. That is, there would either be a token in the blocklist connected to their unique identifier <em>k</em>, or they wouldn‚Äôt have a valid signature on the commitment of their identifier. Also, because of the binding property of the commitment scheme, they cannot connect a different value to the signed commitment œÉ from the identity provider. At the same time, the service provider can block any user by adding their corresponding token to the blocklist.</p>
</li>
<li>
<p>The scheme is also <strong>anonymous</strong>, since all the information sent to the service provider is through a zk-SNARK, revealing no information about the user. In addition, due to the hiding property of the commitment scheme, the identity provider also never learns anything about the user‚Äôs identity.</p>
</li>
<li>
<p>As far as <strong>non-frameability</strong> goes, for an honest user to be prevented from using the service, one would have to produce a token that would tie to the user‚Äôs unique identifier, impossible given the pseudorandomness of the PRF.</p>
</li>
</ul>
<p>However, there is an immediate efficiency flaw in the above construction; the server has to do linear work in the size of the blocklist to verify a user since the proof goes over the whole blocklist every time. At the same time, the proof sizes are also linear in the size of the blocklist. In BLAC, a single proof for a blocklist with 4 million blocks (a size that according to our previous estimations, Reddit would reach in approximately 100 days) would require a client to upload 549MiB of data. Overall, existing zk-SNARK implementations are fit to only handle pieces of the blocklist efficiently.</p>
<h1 id="snarkblock">SNARKBlock</h1>
<p>Enters <a rel="noopener" target="_blank" href="https://eprint.iacr.org/2021/1577.pdf">SNARKBlock</a>, a new anonymous blocklisting scheme from Rosenberg et al. The authors build upon the aforementioned construction and can offer proofs that are only logarithmic in the size of the blocklist, while also requiring logarithmic verification time.</p>
<p>Blocklists mostly stay immutable and the service provider adds to them. As a result, both the service provider and the users end up recomputing a lot of the information. More specifically, if a user has calculated a proof for a blocklist with 99 blocked posts, after a new post gets added they have to calculate a new proof for all 100 posts.
The authors break up the blocklist into non-overlapping chunks so that users can reuse their proof computation over the unchanged chunks. Then they can combine all the distinct proofs into one logarithmic-sized proof (in relation to the blocklist size).
So for our example, we could separate the blocklist into 10 chunks and only have to recompute the proof for the last 10 blocked posts.</p>
<p>There are two immediate problems with the above technique. To begin with, in the original protocol, the proof that was attesting to the validity of the user posting was taking as input the user‚Äôs unique identifier as a witness, making sure that they have not posted any of the blocked posts. What happens though with proofs for different chunks? Each proof would have to take as input the witnesses anew, and a malicious user could potentially have a different identity for a specific chunk, bypassing the block.</p>
<p>Another less obvious problem is the need for rerandomization over the proofs. Reusing a proof for a specific chunk can reveal information that connects the user with previous posts. There are indeed SNARK proofs that allow rerandomization, like the <a rel="noopener" target="_blank" href="https://eprint.iacr.org/2016/260.pdf">Groth16</a> scheme used in SNARKBlock. Nevertheless, the same cannot be said when presenting multiple proofs with a common hidden input.</p>
<p>Both of these problems are solved with the introduction of HICIAP.</p>
<h2 id="hiciap">HICIAP</h2>
<p>The main contribution of SNARKBlock is a new type of zero-knowledge proof, called HIdden Common Input Aggregate Proofs, or HICIAP (pronounced ‚Äúhigh-chop‚Äù). With HICIAP, one can aggregate many zk-SNARKs (specifically Groth16 proofs) of the same relation into a single logarithmic-sized proof and show that they all share a common hidden input. At the same time, it is possible to link multiple HICIAP proofs of different relations, showing in a zero-knowledge proof that those inputs are equal. For our setting, this means that we can (i) have different proofs for each chunk of the blocklist that we aggregate to a single proof and (ii) link that proof with the other distinct proofs to make sure the same secret identity was used for all of them.</p>
<p>Let‚Äôs see now how SNARKBlock‚Äôs protocol differs from the BLAC-inspired inefficient construction. The authors separate the Authentication protocol into <strong>Sync</strong>, which is run by the user offline (i.e., before the authentication has to go through) performing necessary pre-computation, <strong>Attest</strong>, where the user produces and sends the token along with a zk-SNARK to prove eligibility, and <strong>Verify</strong>, where the service provider finally authenticates the user if the SNARK verifies correctly. Overall, the user can gather all the different proofs for each chunk and wrap them in a HICIAP proof, proving they share a common input. Later they can link this HICIAP proof with the rest of the proofs related to honest token extraction and registration.</p>
<p>More specifically, in <strong>Sync</strong>, the user starts by fetching the most recent version of the blocklist and its division into chunks. Then they compute:</p>
<ul>
<li>a proof \( \pi_{chunk_i} \) for each chunk of the blocklist that was altered or updated, proving that the user‚Äôs unique identifier is not correlated with any of the blocks in that chunk; i.e., if the user‚Äôs identifier is <em>k</em>, for all blocks <em>Œ± = (nonce‚Ä≤, h)</em><!--\\( \alpha=(nonce^\prime, h) \\)--> in the chunk, <em>PRF(k, nonce‚Ä≤) ‚â† h</em><!--\\( PRF(k, nonce^\prime) \ne h \\)--></li>
<li>a proof \( \pi_{isu} \) attesting to having registered, i.e. having a witness for a commitment signed by the identity provider</li>
</ul>
<p>When it‚Äôs time to use the service, the <strong>Attest</strong> protocol takes place. The user does the following:</p>
<ul>
<li>computes a proof \(\pi_{token}\) after they have extracted a token Œ±, to prove that the token was computed honestly using their unique identifier <em>k</em>, <em>Œ± = (nonce, PRF(k, nonce))</em></li>
<li>wraps the \( {\pi_{chunk_i}} \) proofs for all chunks, \( \pi_{isu} \) and \(\pi_{token}\) proofs into HICIAP proofs \( \hat{\pi_{chunk}} \), \( \hat{\pi_{isu}} \) and \(\hat{\pi_{token}}\) respectively</li>
<li>produces a proof \( {\pi_{link}} \) that all of the aforementioned HICIAP proofs share the same witness, their unique identifier <em>k</em></li>
<li>sends \( \hat{\pi_{chunk}} \), \( \hat{\pi_{isu}} \), \(\hat{\pi_{token}}\) and \( {\pi_{link}} \) to the service provider.</li>
</ul>
<p>Finally, the service provider checks the validity of the proofs during the <strong>Verification</strong> part.</p>
<h2 id="efficiency">Efficiency</h2>
<p>As noted before, SNARKBlock is much faster than BLAC, since both the verification time and proof size become logarithmic instead of linear in the size of the blocklist. In BLAC, a blocklist with 4 million bans would require a proof of 549MiB, whereas a SNARKBlock attestation for the same size blocklist is only 130KiB, making it feasible for use without elaborate hardware! But does this automatically make SNARKBlock efficient enough to be used in practice? We also cannot forget the extra cost SNARKBlock introduces: offline synchronization.</p>
<p>Here we can see the authors‚Äô evaluation of different-sized blocklists. These include the synchronization time depending on how much the blocklist was altered, the attestation time (which translates to how much time the user takes to produce a proof), the verification time on the service provider‚Äôs side, and the size of the proof, with or without the use of different sized buffers<sup class="footnote-reference"><a href="#4">4</a></sup>.</p>
<!-- add pictures -->
<figure>
 <img src="sync.png" alt="Image 1" style="display: inline-block; width: 45%; margin-right: 1%;">
 <img src="attestation.png" alt="Image 2" style="display: inline-block; width: 45%; margin-right: 1%;">
 <img src="verification.png" alt="Image 3" style="display: inline-block; width: 45%;">
 <img src="proof_size.png" alt="Image 3" style="display: inline-block; width: 45%;">
 <figcaption style="text-align: center;"><a href="https://eprint.iacr.org/2021/1577.pdf">SNARKBlock's evaluation</a> from the paper: (top left) synchronization time depending on blocklist alterations, (top right) attestation time, (bottom left) verification time, and (bottom right) proof size depending on the blocklist size.</figcaption>
</figure>
<p>More specifically, the top left figure shows the offline computation a client must do as a function of the number of changes to the blocklist. This includes syncing chunks and precomputing a proof that they are registered through an identity provider. We can see that the offline precomputation can take up to a couple of minutes for a large number of additions. Since the user can perform it asynchronously and periodically, it doesn‚Äôt introduce any significant overhead.</p>
<p>The top right figure shows the time clients take to attest to non-membership on a blocklist that has recently changed. This is the time it takes for a user to recompute the last chunk proof and link them all together. These results can be interpreted differently considering the different services that SNARKBlock can be used for; if the time to write a message and send it to get posted is smaller than the authentication time (a few seconds here) then the message would get queued. These times seem to be acceptable for forums primarily focused on posting and commenting anonymously. However, the results are impractical for implementations like real-time chat forums, where speed is of the essence and attestation needs to be on the order of milliseconds.</p>
<p>The two bottom graphs show the throughput and proof sizes for server verification. These graphs are in a semi-log scale and do in fact show that SNARKBlock proofs scale logarithmically with the number of elements in the blocklist, both in terms of size and time efficiency on the server‚Äôs side.</p>
<!--The only way to judge the scheme's usability is to consider what service it is being used for. If the time to write a message and send it to get posted is smaller than the authentication time, then the message would have to get queued. From the authors' evaluation, the times could be acceptable for forums primarily focused on posting and commenting anonymously. However, the results are impractical for implementations where speed is of the essence, like real-time chat forums. -->
<h1 id="conclusion">Conclusion</h1>
<p>Anonymous communication systems protect user privacy but face challenges in managing inappropriate behavior. Anonymous blocklisting schemes, powered by advanced cryptographic protocols like zk-SNARKs, enable blocking individual posts without revealing user identities. These schemes use signature and commitment schemes, along with pseudorandom functions, to maintain privacy while ensuring message authenticity.</p>
<p>SNARKBlock addresses inefficiencies in traditional systems by introducing HIdden Common Input Aggregate Proofs (HICIAP), which aggregate multiple proofs into a single efficient proof. This innovation achieves logarithmic proof sizes and verification times in relation to the size of the blocklist, making anonymous blocklisting practical for some large-scale applications, such as social media platforms.</p>
<p>However, further advancements are needed to fully realize a world where anonymous blocklisting schemes are seamlessly deployed and used in everyday applications. Future steps include examining the use of <a rel="noopener" target="_blank" href="https://iacr.org/archive/tcc2008/49480001/49480001.pdf">Incrementally Verifiable Computation</a> (IVC) or recursion techniques in order to recursively combine many proofs into one, and thus further reduce proof sizes and verification times.
Additionally, minimizing the cost of reinstating users without major recomputation is a key challenge that needs addressing to make the schemes more adaptable and user-friendly.
Finally, it is crucial to explore interoperability to ensure that anonymous blocklisting schemes can be seamlessly integrated with existing communication platforms and systems.
By tackling these challenges, we can move closer to using anonymous blocklisting in everyday digital communication.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Technically this is the wrong terminology. The difference between a ‚Äúproof‚Äù and an ‚Äúargument‚Äù in cryptography lies in their soundness definition, which refers to the truthfulness of the protocol: if the statement is false, no Prover can convince a Verifier of the opposite. Proofs have statistical soundness (holds against an unbounded adversary), whereas arguments have only computational soundness (holds against a polynomially bounded adversary). For easier understanding, we can mislabel a SNARK, secure against bounded adversaries, as a ‚Äúproof‚Äù.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>In the world of Avatar, Aang (who is the Avatar) and Toph are part of a team trying to defend the Earth Kingdom against the Fire Nation, led by the Firelord and his son, Zuko. They end up in the city of Ba Sing Se (where Joo Dee resides) which has an authoritarian government refusing to acknowledge that a war is happening.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>While the described scheme has the same general mechanics as BLAC, it is presented in a simplified form that is closer to the SNARKBlock scheme for easier understanding. More details about the protocols can be found in the publications.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>Some of the experiments include a buffer. This optimization aims to fix the problem when the blocklist might be updated during the Sync process, resulting in recomputation during the Attest process and thus added latency. So they use a buffer of smaller chunks at the end of the list and a separate HICIAP instance to process them, which increases the number of distinct proofs but reduces the overall attestation time.</p>
</div>

    </div>

    
    

    <div class="post-footer">
        
            Author: 



  
  


<a href="https:&#x2F;&#x2F;orestischar.com&#x2F;" target=_blank>
  Orestis Chardouvelis
</a>

            <br />
            Approved by:
            
            



  
  


<a href="https:&#x2F;&#x2F;www.andrew.cmu.edu&#x2F;user&#x2F;bparno&#x2F;" target=_blank>
  Bryan Parno,
</a>

            
            



  
  


<a href="https:&#x2F;&#x2F;justinesherry.com&#x2F;" target=_blank>
  Justine Sherry,
</a>

            
            



  
  


<a href="https:&#x2F;&#x2F;noahsinger.org&#x2F;" target=_blank>
  Noah G. Singer
</a>

            <br />
            
                <div class="post-tags">
                    
                        <a href="https://www.cs.cmu.edu/~csd-phd-blog/areas/security/">#Security</a>
                    
                        <a href="https://www.cs.cmu.edu/~csd-phd-blog/areas/systems/">#Systems</a>
                    
                        <a href="https://www.cs.cmu.edu/~csd-phd-blog/areas/theory/">#Theory</a>
                    
                    <br />
                    
                        <a href="https://www.cs.cmu.edu/~csd-phd-blog/tags/cryptography/">#cryptography</a>
                    
                        <a href="https://www.cs.cmu.edu/~csd-phd-blog/tags/zero-knowledge/">#zero-knowledge</a>
                    
                        <a href="https://www.cs.cmu.edu/~csd-phd-blog/tags/snark/">#snark</a>
                    
                        <a href="https://www.cs.cmu.edu/~csd-phd-blog/tags/anonymity/">#anonymity</a>
                    
                </div>
            
            
            <div class="post-nav">
                
                    <a class="previous" href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~csd-phd-blog&#x2F;2024&#x2F;max-extractable-value&#x2F;">‚Äπ Maximal Extractable Value in Ethereum</a>
                
                
                <a class="next" href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~csd-phd-blog&#x2F;2024&#x2F;oblivious-maps&#x2F;">Oblivious Maps for Trusted Execution Environments ‚Ä∫</a>
                
            </div>
            
        

    </div>

    
    
</article>


                </div>
            </main>

            
            
        </div>

      
          <script type="text/javascript" src="https://www.cs.cmu.edu/~csd-phd-blog/even.js" ></script>
      
    </body>

</html>
